<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>CS 11: ocaml track: assignment 6</title>
</head>

<body>

<center>
<h1>Ocaml track: assignment 6: Implementing Scheme, part 2</h1>
</center>
<hr/>

<h2>Goals</h2>

<p>This lab will complete the implementation of a miniature Scheme
interpreter begun in lab 5.  In this lab, we will take the output of parsing
(the AST data structure) and interpret (evaluate) it to give a result.  Lab 5
was all about the boring part of implementing a language; this lab is the fun
part.</p>

<hr/>

<h2>Concepts covered this week</h2>

<ul>
<li>Semantics</li>
<li>Environments</li>
<li>Evaluation</li>
<li>Lexical scoping</li>
</ul>

<hr/>

<h2>Overview</h2>

<h3>Basic sequence of interpretation</h3>

<p>To recap the basic sequence of interpretation, we start off with a file of
source code, represented as a big string.  The steps involved in interpreting
this string and computing results are:</p>

<ul>

<li>convert the string to a sequence of tokens using a <b>lexer</b> (lab
5)</li>

<li>convert the sequence of tokens into one or more S-expressions using a
<b>parser</b> (lab 5)</li>

<li>convert the S-expressions into abstract syntax trees (ASTs) (lab 5)</li>

<li>evaluate the ASTs and compute a result for each AST that gets evaluated
(this lab).</li>

</ul>

<h3>Goal of this lab</h3>

<p>The goal of this lab is to extend the code you wrote for lab 5 and add in
the final piece, which is the code that takes an AST and evaluates it to give
a result.  In order to write this lab you must have working code for lab 5,
so if your lab 5 code isn't working yet, fix that before you start this
lab.</p>

<hr/>

<h2>Semantics of the bogoscheme language</h2>

<p>In this section, we'll describe the semantics of the bogoscheme language
in detail.  Up until now, all we've shown you is the form of the language,
but in order to write an evaluator for a language, you need to know what the
meaning of all legal program expressions are, and what values can be produced
by these expressions.  That's what we'll cover here.</p>

<h3>Values</h3>

<p>The result of evaluating a bogoscheme expression is a bogoscheme value.
Here is the data type of bogoscheme values (from the file
<code>env.mli</code>):</p>

<pre>
(** Identifiers. *)
type id = string

(** Type of legal values i.e. results of evaluation. *)
type value = 
   | Val_unit
   | Val_bool    of bool
   | Val_int     of int
   | Val_prim    of (value list -> value)      (* primitive functions *)
   | Val_lambda  of env * id list * Ast.expr list

(** Type of environments. *)
and env = { parent: env option; bindings: (id, value) Hashtbl.t }
</pre>

<p>We'll discuss environments below.  The first three value types
(<code>Val_unit</code>, <code>Val_bool</code>, and <code>Val_int</code>)
represent unit, boolean, and integer values respectively.
<code>Val_prim</code> values represent primitive (built-in) functions.  These
are functions like <code>print</code> which are not lambda expressions; the
evaluator simply has to know how to evaluate them directly.  Finally,
<code>Val_lambda</code> values represent functions that are defined within
the language <i>i.e.</i> <code>lambda</code> expressions.
<code>lambda</code> expressions contain a list of identifiers (the formal
arguments of the <code>lambda</code> expression), a list of expressions (the
body of the <code>lambda</code> expression), and (perhaps surprisingly) an
environment in which names are looked up.  The relationship of lambda
expressions to their environments will be discussed below.</p>

<p>Evaluation of any bogoscheme expression either results in one of the
values described above, or it results in an error.</p>


<h3>Evaluating expressions</h3>

<p>Expressions in the language are represented by the type &nbsp;
<code>Ast.expr</code>:</p>

<pre>
type id = string

type expr =
   | Expr_unit
   | Expr_bool   of bool
   | Expr_int    of int
   | Expr_id     of id
   | Expr_define of id * expr
   | Expr_if     of expr * expr * expr
   | Expr_lambda of id list * expr list
   | Expr_apply  of expr * expr list
</pre>

<p>There are eight different kinds of expressions, which evaluate as
follows:</p>

<ul>

<li><p>The first three kinds of expressions represent literal constants: the
unit value, boolean values, and integers.  To evaluate them, you just create
the corresponding value (from the <code>value</code> type described above)
and return it as the value of the expression as a whole.</p></li>

<li><p><code>Expr_id</code> represents identifiers.  To evaluate an
identifier, you look it up in the current environment (see below).  The value
of the expression is the value the identifier is bound to in the
environment.</p></li>

<li><p><code>Expr_define</code> represents definitions, which when evaluated
associate an identifier with a value in the current environment (see below).
This expression's value is the unit value.</p></li>

<li><p><code>Expr_if</code> represents <code>if</code> expressions
<i>i.e.</i> conditionals.  An <code>if</code> expression contains three
subexpressions.  The first subexpression is evaluated, and it should evaluate
to a boolean value (if not, it's an error and a <code>Type_error</code>
exception should be raised).  If it evaluates to a "true" (<code>#t</code>)
value, the second subexpression is evaluated, and its value is the value of
the <code>if</code> expression as a whole (in this case, the third expression
is not evaluated).  Alternatively, if the first subexpression evaluates to a
"false" (<code>#f</code>) value, the third subexpression is evaluated, and
its value is the value of the <code>if</code> expression as a whole (in this
case, the second expression is not evaluated).</p></li>

<li><p><code>Expr_lambda</code> represents <code>lambda</code> expressions
<i>i.e.</i> functions.  Evaluating a <code>lambda</code> expression is easy:
you just convert it into the corresponding value (from the <code>value</code>
type described above).</p></li>

<li><p><code>Expr_apply</code> represents a function being applied to an
argument.  We'll talk about how to evaluate function applications
below.</p></li>

</ul>

<h3>Environments</h3>

<p>The notion of an environment is a key concept in implementations of
programming languages.  An environment is a mapping between identifiers in
the language and their values.  In addition, an environment has a pointer to
its "enclosing environment", unless it is a special environment called the
"global environment" or "top-level environment".  Here's how we represent
environments in the evaluator:</p>

<pre>
(** Type of environments. *)
and env = { parent: env option; bindings: (id, value) Hashtbl.t }
</pre>

<p>The <code>and</code> is because this piece of code is part of the code
shown above when we described the <code>value</code> type; the
<code>value</code> type and the <code>env</code> type are actually
mutually-recursive types (each depends on the other).  Environments are
represented as an ocaml record type.  The identifier/value mappings are
represented by an ocaml hash table, which is a value of type
<code>Hashtbl.t</code> in the ocaml standard library (you should browse the
ocaml documentation <a
href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html">here</a>
to find out more about ocaml hash tables).  This forms the
<code>bindings</code> field of the record.  The enclosing environment is
represented by a value of type <code>env option</code> because there may or
may not be an enclosing environment (there will be for all environments
except for the global environment).</p>

<p>Note that a hash table is <u>not</u> a purely functional data structure,
so you can mutate the contents of a hash table in-place.  In fact, this is
the normal way to use a hash table, and you should do that where appropriate
in this lab.</p>

<p>Environments are used to record the values of identifiers in bogoscheme
expressions.  It is important to understand that evaluation of expressions
can <u>only</u> be done in the context of a particular environment.  Without
environments, the only expressions that could be evaluated would be ones
without any identifiers, which would make the language nothing more than a
glorified calculator.  Since most expressions have one or more identifiers,
and we need environments to give meaning to these identifiers, we simply
require that evaluation of any expression must always be done in the context
of some environment.  Put differently, an environment is the representation
of the context in which an expression is evaluated.</p>

<p>To emphasize this last point, let's look at the type of the evaluator
function, from <code>eval.mli</code>:</p>

<pre>
val eval : Ast.expr -> Env.env -> Env.value
</pre>

<p>What this says is that the evaluator takes an AST expression and an
environment, and produces a value.  Without an environment, the function
cannot be called and so no value will be produced.</p>

<p>Evaluation of certain kinds of expressions can create, access or modify
bindings in environments, as follows:</p>

<ul>

<li><p>Evaluating an identifier expression (<code>Expr_id</code>) is done by
looking up the identifier in the environment.  In our implementation, this is
done by looking it up in the <code>bindings</code> hash table.  If it isn't
found there, then the parent environment (if it exists) is searched.  If
there is no parent environment (which means that you searched all the way up
to the global environment and still couldn't find a binding for the
identifier), a <code>Not_found</code> exception is raised.</p></li>

<li><p>Evaluating a <code>define</code> expression (<code>Expr_define</code>)
is done by first evaluating the subexpression to get a value.  Then the
identifer and the value are associated with each other in the
<code>bindings</code> hash table of the current environment.  Note that you
do not create a new environment while evaluating a <code>define</code>
expression; you merely add a binding to an existing environment.</p></li>

<li><p>Evaluating function applications also involves environments; this is
discussed in the next section.</p></li>

</ul>

<p>Note that all of the hash table manipulations are kept inside the
<code>env.ml</code> file; the rest of the code only sees the abstract
interface to environments as defined in the <code>env.mli</code> file.  We'll
let you figure out which hash table functions are most appropriate for
implementing the environment interface.  The good news is that the
environment code is extremely simple to implement; all the hard work has
already been done for you in the hash table implementation.</p>

<h3>Evaluating function applications</h3>

<p>Evaluating function applications (<code>Expr_apply</code> in the
expression type) is a bit involved, so we'll discuss it in detail here.  It
consists of the following steps:</p>

<ol>

<li><p>Evaluate all of the arguments to the function (the <code>expr
list</code> in <code>Eval_apply of expr * expr list</code>) in any order.
All of these expressions are evaluated in the current environment.  The
result of this is a list of values.</p></li>

<li><p>Evaluate the function itself (the <code>expr</code> in
<code>Eval_apply of expr * expr list</code>).  This should either evaluate to
a primitive function (<code>Val_prim</code> in the <code>value</code> type)
or a <code>lambda</code> value (<code>Val_lambda</code> in the
<code>value</code> type).  Anything else is an error, and a
<code>Type_error</code> exception should be raised.</p></li>

<li><p>If the function evaluates to a <code>Val_prim</code> value (primitive
function), then just apply that function to the evaluated argument list.  The
result is the result of the function application as a whole.</p></li>

<li><p>If the function evaluates to a <code>Val_lambda</code> value
(<code>lambda</code> value), then things become a bit more complicated.  In
this case, you need to do the following:</p>

<ol type="a">

<li><p>Create a brand-new environment which maps the argument names of the
<code>lambda</code> expression (the <code>id list</code> in <code>Expr_lambda
of id list * expr list</code>) to the list of values you computed in step 1
above.  So if the argument names were <code>x</code>, <code>y</code>, and
<code>z</code> and the computed values were <code>1</code>, <code>2</code>,
and <code>3</code>, the environment would map <code>x</code> to
<code>1</code>, <code>y</code> to <code>2</code>, and <code>z</code> to
<code>3</code>.</p></li>

<li><p>The parent environment of this new environment is the environment from
the <code>lambda</code> expression (the <code>env</code> component).  This is
the environment in which the lambda expression was originally defined.
<b>Note:</b> the environment in which the function application is being
evaluated is <u>not</u> used to create the new environment.</p></li>

<li><p>Now that you have the new environment, you simply evaluate the code in
the body of the <code>lambda</code> expression (the <code>expr list</code> in
<code>Expr_lambda of id list * expr list</code>) in the context of this new
environment.</p></li>

</ol>

</li>

</ol>

<p>And that's it.  This way of handling environments and creating new
environments every time you apply a <code>lambda</code> expression to its
arguments is known as <b>lexical scoping</b>.  If you've taken CS 1, this
should seem familiar to you -- you have just implemented the environment
model of Scheme (aside from <code>set!</code>, which is not part of our
langauge..</p>

<hr/>

<h2>Program to write</h2>

<p>Your job in this lab is to complete the bogoscheme interpreter you began
in lab 5.</p>

<p>Just like lab 5, there are a lot of supporting files for this lab, and
we've again prepared a tarball of all the files, which is located <a
href="./lab6.tar">here</a>.  To unpack it, do:</p>

<pre>
% tar xvf lab6.tar
</pre>

<p>Again, just like lab 5, a lot of the code has already been written for you
and should not be changed.  The only files that will need changing are the
following:</p>

<ul>

<li>the files <code>lexer.mll</code>, <code>parser.mly</code>, and
<code>ast.ml</code> should be copied over from your completed lab 5
code.</li>

<li>the files <code>env.ml</code> and <code>eval.ml</code> should be
completed at the places marked "TODO".  Of course, the "TODO" comments should
be removed.</li>

</ul>

<p>In particular, note that we provide interface files (<code>.mli</code>
files) for all the modules in the lab, which you should read, as the comments
in those files will prove valuable to you.</p>

<p>We provide the files <code>main.ml</code> and <code>primitives.ml</code>,
which do not need to be changed, but which you should read anyway.
<code>main.ml</code> is the entry point to the interpreter, while
<code>primitives.ml</code> contains the implementations of primitive
functions.  These include arithmetic operators (<code>+</code>,
<code>-</code>, <code>*</code>, <code>/</code>), comparison operators
(<code>=</code>, <code>!=</code>, <code><</code>, <code>></code>,
<code><=</code>, <code>>=</code>), and the <code>print</code> function.</p>

<p>We also provide a <code>Makefile</code>.  Typing &nbsp; <code>make</code>
&nbsp; will make the bogoscheme interpreter, which is called <code>bs</code>.
Typing &nbsp; <code>make test</code> &nbsp; will run the test script (see
below).  Typing &nbsp; <code>make clean</code> &nbsp; will remove all the
files created during compilation.</p>

<p>The file <code>env.ml</code> contains the implementation of environments,
while <code>eval.ml</code> contains the evaluator itself.  Again, these are
the only files in this lab that you need to edit, aside from copying over
your parsing code from lab 5.  You need to add less than 10 lines of code to
<code>env.ml</code>, and less than 30 lines of code to <code>eval.ml</code>.
This lab is heavy on thinking and very light on actual coding, so take your
time and make sure you understand what you're doing.</p>

<hr/>

<h2>Testing the code</h2>

<p>The bogoscheme interpreter will be an executable called <code>bs</code>,
and it will be invoked as follows:</p>

<pre>
% bs filename.bs
</pre>

<p>for some Scheme source code file called <code>filename.bs</code>.  We have
created a number of Scheme source code files in the <code>tests/</code>
subdirectory of the code.  You can run them separately <i>e.g.</i></p>

<pre>
% bs tests/test_factorial.bs
</pre>

<p>or you can just type <code>make test</code>, which will run the test
script <code>run_test</code>.  This will run all the test programs.  If all
is well, the test programs will print one or more <code>#t</code> values to
the terminal.  If anything else is printed (aside from lines indicating which
test script is being run and how many <code>#t</code>s should be printed), it
means that an error occurred, which in turn means that your interpreter has a
bug which you should fix.</p>

<hr/>

<h2>To hand in</h2>

<p>The files <code>env.ml</code> and <code>eval.ml</code>.</p>

<hr/>

<h2>References</h2>

<ul>

<li><p>Documentation for the ocaml <a
href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html">hash
table</a> module.</p></li>

</ul>

<hr/>

</body>
</html>

